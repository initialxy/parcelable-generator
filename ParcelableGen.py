"""
Copyright (C) 2013 initialxy and other contributors
http://code.google.com/p/parcelable-generator/

Permission is hereby granted, free of charge, to any person obtaining a copy of
this software and associated documentation files (the "Software"), to deal in
the Software without restriction, including without limitation the rights to
use, copy, modify, merge, publish, distribute, sublicense, and/or sell copies
of the Software, and to permit persons to whom the Software is furnished to do
so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
"""

"""
A utility to generate Java codes in order to make a class Parcelable. Run this
script with
>> python ParcelableGen.py
Copy and paste your Java class into stdin, signify end of file (ctrl+z on
windows or ctrl+d on *nix), then press enter. Java codes will be printed to
stdout. Copy and paste generated code into your Java file. You probably want to
press shift+ctrl+o then shift+ctrl+f in Eclipse afterwards. It could make
mistakes, so sometimes manual editing is required. For one, it cannot correctly
detect enums (it's not that smart). It detects enums by checking if type name
ends with "Type". If it gets wrong, you might want to temporarily change type
name (either add or remove "Type" from its end), generate, then manually
correct type name. But it still makes your life much easier.
"""

import sys
import re

CLASS_REGEX = re.compile(r"^\s*public (static |)(abstract |)class\s+(\S+)\s+.*")
MEMBER_REGEX = re.compile(r"^\s*(public|private)\s+(\S+)\s+(\S+)\;.*")
GENERICS_REGEX = re.compile(r"\s*(\S+)\<(.+)\>.*")

SUPPORTED_TYPES = ["byte", "double", "float", "int", "long", "String",
        "java.lang.String", "boolean[]", "byte[]", "char[]", "double[]", 
        "float[]", "int[]", "long[]", "String[]"]

SUPPORTED_TYPES_METHOD_NAMES = ["Byte", "Double", "Float", "Int", "Long",
        "String", "String", "BooleanArray", "ByteArray", "CharArray", "DoubleArray",
        "FloatArray", "IntArray", "longArray", "StringArray"]

TEMPLATE = """
    /**************************************************************************
     * Code to make this class Parcelable. Generated by ParcelableGen.py
     */

    public static final Parcelable.Creator<{className}> CREATOR = new Creator();

    /**
	 * Default constructor, needed for Jackson. Remove if necessary.
	 */
	public {className}() {
	}

	/**
	 * Reconstruct from Parcel
	 */
	public {className}(Parcel in) {
		{read}
	}

	@Override
	public void writeToParcel(Parcel out, int flags) {
		{write}
	}

	@Override
	public int describeContents() {
		return 0;
	}

	private static class Creator implements Parcelable.Creator<{className}> {
		public {className} createFromParcel(Parcel source) {
			return new {className}(source);
		}

		public {className}[] newArray(int size) {
			return new {className}[size];
		}
	}

    /**************************************************************************
     * Parcelable codes end
     */
    """

class Generator:
    def __init__(self):
        self.reset()

    def reset(self):
        self.className = ""
        self.members = []

    def setClassName(self, className):
        self.className = className;

    def addMember(self, dataType, name):
        self.members.append((dataType, name))

    def isList(self, dataType):
        return dataType.startswith("List") or dataType.startswith("ArrayList") \
                or dataType.startswith("LinkedList") \
                or dataType.startswith("java.util.List") \
                or dataType.startswith("java.util.ArrayList") \
                or dataType.startswith("java.util.LinkedList")

    def isEnum(self, dataType):
        return dataType.endswith("Type")

    def isSupportedType(self, dataType):
        return dataType in SUPPORTED_TYPES

    def genReadSupportedType(self, member):
        return member[1] + " = in.read" \
                + SUPPORTED_TYPES_METHOD_NAMES[SUPPORTED_TYPES.index(member[0])] \
                + "();"

    def genWriteSupportedType(self, member):
        return "out.write" \
                + SUPPORTED_TYPES_METHOD_NAMES[SUPPORTED_TYPES.index(member[0])] \
                + "(" + member[1] + ");" \

    def genReadBoolean(self, member):
        return "boolean[] " + member[1] + "Array = new boolean[1];\n" \
		        + "\t\tin.readBooleanArray(" + member[1] + "Array);\n" \
		        + "\t\t" + member[1] + " = " + member[1] + "Array[0];"

    def genWriteBoolean(self, member):
        return "out.writeBooleanArray(new boolean[] { " + member[1] + " });"

    def genReadCalendar(self, member):
        return member[1] + " = null;\n" \
                + "\t\tString " + member[1] + "Str = in.readString();\n" \
                + "\t\tif (" + member[1] + "Str != null) {\n" \
                + "\t\t\t" + member[1] + " = " + member[0] + ".getInstance();\n" \
                + "\t\t\tFormats.XML_DATETIME.setTimeZone(" + member[1] + ".getTimeZone());\n" \
                + "\t\t\ttry {\n" \
                + "\t\t\t\t" + member[1] + ".setTime(Formats.XML_DATETIME.parse(" + member[1] + "Str));\n" \
                + "\t\t\t} catch (ParseException pe) {}\n" \
                + "\t\t}"        

    def genWriteCalendar(self, member):
        return "if (" + member[1] + " != null) {\n" \
                + "\t\t\tFormats.XML_DATETIME.setTimeZone(" + member[1] + ".getTimeZone());\n" \
                + "\t\t\tout.writeString(Formats.XML_DATETIME.format(" + member[1] + ".getTime()));\n" \
                + "\t\t} else {\n" \
                + "\t\t\tout.writeString(null);\n" \
                + "\t\t}"

    def genReadGregorianCalendar(self, member):
        return member[1] + " = null;\n" \
                + "\t\tString " + member[1] + "Str = in.readString();\n" \
                + "\t\tif (" + member[1] + "Str != null) {\n" \
                + "\t\t\t" + member[1] + " = new " + member[0] + "();\n" \
                + "\t\t\tFormats.XML_DATETIME.setTimeZone(" + member[1] + ".getTimeZone());\n" \
                + "\t\t\ttry {\n" \
                + "\t\t\t\t" + member[1] + ".setTime(Formats.XML_DATETIME.parse(" + member[1] + "Str));\n" \
                + "\t\t\t} catch (ParseException pe) {}\n" \
                + "\t\t}"        

    def genWriteGregorianCalendar(self, member):
        return self.genWriteCalendar(member)

    def genReadXMLGregorianCalendar(self, member):
        return "try {\n" \
                + "\t\t\t" + member[1] + " = javax.xml.datatype.DatatypeFactory.newInstance().newXMLGregorianCalendar(in.readString());\n" \
                + "\t\t} catch (DatatypeConfigurationException dce) {}"

    def genWriteXMLGregorianCalendar(self, member):
        return "out.writeString(" + member[1] + ".toString());";

    def genReadBigDecimal(self, member):
        return "String " + member[1] + "Str = in.readString();\n" \
                + "\t\tif (" + member[1] + "Str != null) {\n" \
                + "\t\t\t" + member[1] + " = new " + member[0] + "(" + member[1] + "Str);\n" \
                + "\t\t} else {\n" \
                + "\t\t\t" + member[1] + " = null;\n" \
                + "\t\t}"        

    def genWriteBigDecimal(self, member):
        return "if (" + member[1] + " != null) {\n" \
                + "\t\t\tout.writeString(" + member[1] + ".toString());\n" \
                + "\t\t} else {\n" \
                + "\t\t\tout.writeString(null);\n" \
                + "\t\t}"

    def genReadBigInteger(self, member):
        return self.genReadBigDecimal(member)

    def genWriteBigInteger(self, member):
        return self.genWriteBigDecimal(member)

    def genReadInteger(self, member):
        nullFlag = member[1] + "NullFlag"
        result = "boolean " + nullFlag + ";\n"
        m = ["boolean", nullFlag]
        result += "\t\t" + self.genReadBoolean(m)
        result += "\n\t\tif (" + nullFlag + ") {\n" \
                + "\t\t\t" + member[1] + " = null;\n" \
                + "\t\t\tin.readInt();\n" \
                + "\t\t} else {\n" \
                + "\t\t\t" + member[1] + " = in.readInt();\n" \
                + "\t\t}"
        return result;

    def genWriteInteger(self, member):
        result = ""
        m = ["boolean", member[1] + " == null"]
        result += self.genWriteBoolean(m)
        result += "\n\t\tif ("+member[1]+" != null){\n" \
                + "\t\t\tout.writeInt("+member[1]+".intValue());\n" \
                + "\t\t} else {\n" \
                + "\t\t\tout.writeInt(0);\n" \
                + "\t\t}"
        return result

    def genReadDouble(self, member):
        nullFlag = member[1] + "NullFlag"
        result = "boolean " + nullFlag + ";\n"
        m = ["boolean", nullFlag]
        result += "\t\t" + self.genReadBoolean(m)
        result += "\n\t\tif (" + nullFlag + ") {\n" \
                + "\t\t\t" + member[1] + " = null;\n" \
                + "\t\t\tin.readDouble();\n" \
                + "\t\t} else {\n" \
                + "\t\t\t" + member[1] + " = in.readDouble();\n" \
                + "\t\t}"
        return result;

    def genWriteDouble(self, member):
        result = ""
        m = ["boolean", member[1] + " == null"]
        result += self.genWriteBoolean(m)
        result += "\n\t\tif ("+member[1]+" != null){\n" \
                + "\t\t\tout.writeDouble("+member[1]+".doubleValue());\n" \
                + "\t\t} else {\n" \
                + "\t\t\tout.writeDouble(0.0);\n" \
                + "\t\t}"
        return result

    def genReadBooleanObj(self, member):
        nullFlag = member[1] + "NullFlag"
        boolValue = member[1] + "BoolValue"
        result = "boolean " + nullFlag + ";\n"
        m = ["boolean", nullFlag]
        result += "\t\t" + self.genReadBoolean(m)
        result += "\n\t\tboolean " + boolValue + ";\n"
        m[1] = boolValue
        result += "\t\t" + self.genReadBoolean(m)
        result += "\n\t\tif (" + nullFlag + ") {\n" \
                + "\t\t\t" + member[1] + " = null;\n" \
                + "\t\t} else {\n" \
                + "\t\t\t" + member[1] + " = " + boolValue + ";\n" \
                + "\t\t}"
        return result;

    def genWriteBooleanObj(self, member):
        boolValue = member[1] + "BoolValue"
        result = "boolean " + boolValue + ";\n"
        m = ["boolean", member[1] + " == null"]
        result += "\t\t" + self.genWriteBoolean(m)
        result += "\n\t\tif ("+member[1]+" != null){\n" \
                + "\t\t\t" + boolValue + " = " + member[1] + ".booleanValue();\n" \
                + "\t\t} else {\n" \
                + "\t\t\t" + boolValue + " = false;\n" \
                + "\t\t}\n"
        m[1] = boolValue
        result += "\t\t" + self.genWriteBoolean(m)
        return result

    def genReadEnum(self, member):
        return "String " + member[1] + "Str = in.readString();\n" \
                + "\t\tif (" + member[1] + "Str != null) {\n" \
                + "\t\t\t" + member[1] + " = " + member[0] + ".valueOf(" + member[1] + "Str);\n" \
                + "\t\t} else {\n" \
                + "\t\t\t" + member[1] + " = null;\n" \
                + "\t\t}"        

    def genWriteEnum(self, member):
        return "if (" + member[1] + " != null) {\n" \
                + "\t\t\tout.writeString(" + member[1] + ".name());\n" \
                + "\t\t} else {\n" \
                + "\t\t\tout.writeString(null);\n" \
                + "\t\t}"

    def genReadList(self, member):
        generics = ""
        listType = ""

        m = GENERICS_REGEX.match(member[0])
        if m:
            generics = m.group(2)
            listType = m.group(1)
        else:
            listType = member[0]

        if listType == "" or listType == "List" or listType == "java.util.List":
            listType = "LinkedList"

        return member[1] + " = new " + listType + "<" + generics + ">();\n" \
		        "\t\tin.readList(" + member[1] + ", " + generics + ".class.getClassLoader());"

    def genWriteList(self, member):
        return "out.writeList(" + member[1] + ");"

    def genReadParcelable(self, member):
        return member[1] + " = in.readParcelable(" + member[0] + ".class.getClassLoader());"

    def genWriteParcelable(self, member):
        return "out.writeParcelable(" + member[1] + ", 0);"

    def gen(self):
        out = TEMPLATE.replace("{className}", self.className)

        read = ""
        write = ""

        for m in self.members:
            if self.isSupportedType(m[0]):
                read += "\n\t\t" + self.genReadSupportedType(m)
                write += "\n\t\t" + self.genWriteSupportedType(m)
            elif m[0] == "boolean":
                read += "\n\t\t" + self.genReadBoolean(m)
                write += "\n\t\t" + self.genWriteBoolean(m)
            elif m[0] == "Calendar" or m[0] == "java.util.Calendar":
                read += "\n\t\t" + self.genReadCalendar(m)
                write += "\n\t\t" + self.genWriteCalendar(m)
            elif m[0] == "GregorianCalendar" \
                    or m[0] == "java.util.GregorianCalendar":
                read += "\n\t\t" + self.genReadGregorianCalendar(m)
                write += "\n\t\t" + self.genWriteGregorianCalendar(m)
            elif m[0] == "XMLGregorianCalendar" \
                    or m[0] == "javax.xml.datatype.XMLGregorianCalendar":
                read += "\n\t\t" + self.genReadXMLGregorianCalendar(m)
                write += "\n\t\t" + self.genWriteXMLGregorianCalendar(m)
            elif m[0] == "BigDecimal" or m[0] == "java.math.BigDecimal":
                read += "\n\t\t" + self.genReadBigDecimal(m)
                write += "\n\t\t" + self.genWriteBigDecimal(m)
            elif m[0] == "BigInteger" or m[0] == "java.math.BigInteger":
                read += "\n\t\t" + self.genReadBigInteger(m)
                write += "\n\t\t" + self.genWriteBigInteger(m)
            elif m[0] == "Integer" or m[0] == "java.lang.Integer":
                read += "\n\t\t" + self.genReadInteger(m)
                write += "\n\t\t" + self.genWriteInteger(m)
            elif m[0] == "Double" or m[0] == "java.lang.Double":
                read += "\n\t\t" + self.genReadDouble(m)
                write += "\n\t\t" + self.genWriteDouble(m)
            elif m[0] == "Boolean" or m[0] == "java.lang.Boolean":
                read += "\n\t\t" + self.genReadBooleanObj(m)
                write += "\n\t\t" + self.genWriteBooleanObj(m)
            elif self.isEnum(m[0]):
                read += "\n\t\t" + self.genReadEnum(m)
                write += "\n\t\t" + self.genWriteEnum(m)
            elif self.isList(m[0]):
                read += "\n\t\t" + self.genReadList(m)
                write += "\n\t\t" + self.genWriteList(m)
            else:
                read += "\n\t\t" + self.genReadParcelable(m)
                write += "\n\t\t" + self.genWriteParcelable(m)

        out = out.replace("{read}", read.strip())
        out = out.replace("{write}", write.strip())

        print out

def main():
    lines = sys.stdin.readlines()
    gen = Generator()

    for line in lines:
        m = MEMBER_REGEX.match(line)

        if m:
            gen.addMember(m.group(2), m.group(3))
            continue;

        m = CLASS_REGEX.match(line)
        
        if m:
            gen.setClassName(m.group(3))
            continue

    gen.gen()

main()
